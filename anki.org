#+title: Anki
#+startup: content

* notitia :clean_code:
** 20:48
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653760554056
:END:
*** Front
which 2 words should be used when we use variables for *copying* or *moving* from one directoion to another
*** Back
*source* and *destination*
** 20:54 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653760554161
:END:
*** Front
why using *pronounceable* names important?
*** Back
because *pronouncing*, *discussing* about this variable will be easier. also *searching* is easier.
** 21:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653761082931
:END:
*** Front
why using *encodings* like *Hungarian Notation* is a bad idea?
*** Back
because it add a *metal load* to the code. programmer will need to _decipher_ every variable name. also *searching* is *hard*. and *miss spelling* them is easy!
** 21:07 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
how to reference class properties in java?
*** Back
#+begin_src java
this.your_property
#+end_src
** 22:19 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766195648
:END:
*** Front
is including *verb* words inside *class names* good idea?
*** Back
No. It should be *noun*
** 22:23 :programming:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766195749
:END:
*** Front
what *predicate method* means in programming?
*** Back
methods that return *boolean* like ~true~ or ~false~
** 22:27 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766195823
:END:
*** Front
how *predicate methods* should be named?
*** Back
~isEven()~, ~isEmpty()~ and so on.
** 22:32 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766561148
:END:
*** Front
what is *accessor method* means?
*** Back
it accesses a *property* of a class
** 22:33 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766561223
:END:
*** Front
what *mutator method* means?
*** Back
it mutates (changes) a *property or a class*
** 22:34 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766561323
:END:
*** Front
how *mutator methods* should be names?
*** Back
use ~set~ prefix. like ~setName("savolla")~
** 22:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766561398
:END:
*** Front
how *accessor methods* should be names?
*** Back
use ~get~ prefix. like ~getName()~
** 22:37 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018124
:END:
*** Front
what is *static factory* methods?
*** Back
TODO
** 22:58 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018199
:END:
*** Front
what is *punning* in coding?
*** Back
it's where you use words which has *multiple meanings*. like ~add()~. where it can be understood as *summing* or *inserting*
** 23:01 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018273
:END:
*** Front
what is the better word alternative than *add* when you adding some element to an *array* or *list*?
*** Back
*append*
** 23:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018349
:END:
*** Front
what is the better word alternative than *add* when you _summing values_?
*** Back
~sum~
** 23:05 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018423
:END:
*** Front
what is *visitor pattern*?
*** Back
TODO
** 23:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018499
:END:
*** Front
is using *problem domain concept names* as variable,class names a good idea?
*** Back
yes.
** 2022.05.29-12:50:25 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653818626939
:END:
*** Front
what is the smallest thing of organization in programs?
*** Back
functions
** 2022.05.29-12:52:52 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653818627039
:END:
*** Front
how boolean type is represented in java?
*** Back
~boolean~
** 2022.05.29-12:59:16 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653818627138
:END:
*** Front
what is *JUnit*?
*** Back
it's a *testing framework* for *Java*
** 2022.05.29-13:02:45 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653818627238
:END:
*** Front
the first rule of functions is that *they should be small* the second rule of functions is that ...
*** Back
they should be smaller that that!
** 2022.05.29-13:08:59 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773362
:END:
*** Front
how many *lines* should ~if~, ~else~, ~else if~, ~for~ or ~while~ blocks contain?
*** Back
just 1 line!
** 2022.05.29-13:11:38 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773462
:END:
*** Front
why code blocks (if, else, for, while) should contain just 1 line?
*** Back
1. they add *documentational* value
2. it makes code very *readable*
** 2022.05.29-13:13:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773565
:END:
*** Front
code block should only contain 1 line of code. what that one line would be?
*** Back
it's a function call!
** 2022.05.29-13:16:31 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773663
:END:
*** Front
what is the maximum *indent level* of a function?
*** Back
just one!! (or maybe 2)
** 2022.05.29-13:17:27 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773762
:END:
*** Front
why maximum indentation level of function blocks should be only 1?
*** Back
it makes code very easy to read and understand
** 2022.05.29-13:20:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773862
:END:
*** Front
functions should do ... and they should do it ...
*** Back
1. one thing
2. well
** 2022.05.29-13:24:47 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773938
:END:
*** Front
how to write a *docstring* for a function?
*** Back
1. use the word "TO" as a prefix to the *function name*
2. if function name is in a *verbal* form then it will be more easier to describe it
3. for example "To renderPageWithSetups we first create page and then add setups" is a very nice example of a docstring
** 2022.05.29-13:29:56 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820774012
:END:
*** Front
how to understand if a function is doing *more than one thing*?
*** Back
we write a *docstring* using *TO* prefix and see if we have multiple tasks inside a function
** 2022.05.29-13:47:36 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119013
:END:
*** Front
what is *stepdown rule*?
*** Back
reading the program by *descending* one level of abstraction at a time
** 2022.05.29-13:55:10 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119088
:END:
*** Front
how do we make applying *stepdown rule* more easily?
*** Back
by using *TO* paragraphs as *docstrings*.
** 2022.05.29-14:05:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119188
:END:
*** Front
what is *abstract factory*?
*** Back
TODO
** 2022.05.29-14:06:11 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119287
:END:
*** Front
which SOLID principle does *switch* statements brake?
*** Back
1. SRP (single responsibility principle)
2. OCP (open close principle)
** 2022.05.29-14:07:15 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119362
:END:
*** Front
how to deal with *switch statements* in terms of *clean code*?
*** Back
put it behind an *Abstract Factory*
** 2022.05.29-14:09:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119437
:END:
*** Front
when *switch statements* can be tolerated and not creating an *abstract factory* for them?
*** Back
if they appear *only once* in the code.
** 2022.05.29-14:11:25 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119538
:END:
*** Front
write a code example of *implementing* an *interface* in java
*** Back
#+begin_src java
public class A implements B {
    ...
}
#+end_src
** 2022.05.29-14:14:17 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119612
:END:
*** Front
which *postfix* should be used in the name of class if it *implements* some interface?
*** Back
~Impl~.
Example: ~public class EmployeeFactoryImpl implements EmployeeFactory {~
** 2022.05.29-14:17:24 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119687
:END:
*** Front
#+begin_quote
you know you are working on ... when each routine turns out to be pretty much what you ...
#+end_quote

*** Back
1. clena code
2. expected
** 2022.05.29-14:29:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598198
:END:
*** Front
a *long* descriptive name is better than a ... . a long descriptive name is better than a ...
*** Back
1. *short cryptic* name
2. long descriptive *comment*
** 2022.05.29-14:33:04 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598293
:END:
*** Front
is spending time to find a good variable, class or function name a good idea?
*** Back
definitely yes!
** 2022.05.29-14:34:40 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598471
:END:
*** Front
what benefit can *choosing descriptive names* bring to your module, class or function?
*** Back
1. better understanding of the module
2. can help to *improve* the module by *favorable redesigning*
** 2022.05.29-14:39:00 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598590
:END:
*** Front
what *niladic* function means?
*** Back
function with *zero arguments*
** 2022.05.29-14:40:12 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598799
:END:
*** Front
what *monadic function* means?
*** Back
function with *only one* parameter
** 2022.05.29-14:40:48 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598894
:END:
*** Front
what *dyadic function* means?
*** Back
function with *two parameters*
** 2022.05.29-14:41:20 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598966
:END:
*** Front
what *triadic function* means?
*** Back
function with *three arguments*
** 2022.05.29-14:41:58 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824599043
:END:
*** Front
what *polyadic function* means?
*** Back
function with *more than three parameters*
** 2022.05.29-14:54:17 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708537
:END:
*** Front
you should avoid more than ... function arguments
*** Back
2
** 2022.05.29-14:57:52 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708612
:END:
*** Front
what is the biggest reason why we have to avoid too much function arguments ?
*** Back
*testing* becomes harder when arguments increase
** 2022.05.29-15:15:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708688
:END:
*** Front
what are the 3 forms of *monadic functions*?
*** Back
1. question monads
2. operator monads
3. event monads
** 2022.05.29-15:16:41 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708763
:END:
*** Front
*question monadic functions* include ... word as prefix and returns a ... value. they ... mutate the argument
*** Back
1. "is"
2. boolean
3. do not
** 2022.05.29-15:18:18 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708838
:END:
*** Front
*operator monadic functions* ... the input argument and returns the ... version
*** Back
1. transforms
2. modified
** 2022.05.29-15:21:13 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708912
:END:
*** Front
what is *event monadic function* ?
*** Back
alters the *state of the system* and does not return anything
** 2022.05.29-15:24:54 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708987
:END:
*** Front
why passing *booleans* as parameters to a function is a *bad idea*?
*** Back
because it's clear that this function *does more than one thing*. one for ~true~ value and one for ~false~ value.
** 2022.05.29-15:27:01 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709062
:END:
*** Front
how to heal functions that take *booleans* as parameter?
*** Back
create two separate functions. one for ~true~ value and another for ~false~ value
** 2022.05.29-15:35:07 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709138
:END:
*** Front
what should we do if function has to take more than 2 arguments and arguments inside are a part of concept (like x,y,z values of a 3D point)?
*** Back
create a special *struct* or *class* for these arguments (like class Point) and pass the new *class object* instead
** 2022.05.29-15:40:55 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709238
:END:
*** Front
*dyadic functions* require us to remember *the order of arguments*. how can we solve this small issue?
*** Back
by putting the order inside the name of the function.
#+begin_src java
assert(expected, actual)
#+end_src
becomes
#+begin_src java
assertExpectedEqualsActual(expected, actual)
#+end_src
** 2022.05.29-15:48:19 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709313
:END:
*** Front
what is *side effects* of a function?
*** Back
when function modifies things that are not inside its scope.
** 2022.05.29-15:50:13 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709388
:END:
*** Front
give examples of *side effects* of functions
*** Back
1. global variable modification
2. class attribute modification
3. initializing and using other classes
** 2022.05.29-16:08:27 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653830475287
:END:
*** Front
what can we do to avoid *output function arguments*?
*** Back
use OO. output arguments can be used as class objects
#+begin_src python
negate(number) # don't do this
number.negate() # do this!
#+end_src
** 2022.05.29-16:20:22 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653830475363
:END:
*** Front
use ... instead of using *error codes in if statements*
*** Back
try / catch blocks
** 2022.05.29-17:16:16 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264438
:END:
*** Front
how many lines should *try/catch* blocks contain?
*** Back
only 1
** 2022.05.29-17:17:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264513
:END:
*** Front
what *catch* blocks should contain?
*** Back
function call
** 2022.05.29-17:17:49 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264588
:END:
*** Front
which *postfix* should be used for the function that is being called inside a *catch* block?
*** Back
~Error~
** 2022.05.29-17:28:21 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264688
:END:
*** Front
what are the rules of *structured programming*?
*** Back
1. functions contain only one ~return~ statement
2. no ~break~ or ~continue~ statements in a loop
3. never use ~goto~ statements
** 2022.05.29-17:32:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264763
:ANKI_FAILURE_REASON: Note was not found: 1653835264763
:END:
*** Front
how to write functions like Uncle Bob suggests in his *Clean Code* book?
*** Back
1. write the function without any prettifying
** 2022.05.29-17:35:57 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264838
:END:
*** Front
what are the steps for refining a function? (massaging the code)
*** Back
1. reduce number of *indenting*
2. fix *nested loops*
3. shorten *argument list*
4. find *better names*
5. remove *duplicated code*
** 2022.05.29-18:23:21 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653839189463
:END:
*** Front
why *comments* are liers?
*** Back
because programmers update the code below and usually forget to update the comments above
** 2022.05.29-18:25:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653839189538
:END:
*** Front
instead of writing *comments* you better express yourself better in the ...
*** Back
1. code
** 2022.05.29-18:35:32 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653839189638
:END:
*** Front
what is the java statement for testing an object if it's an instance of a particular class
*** Back
~instanceof~
** 2022.05.29-18:36:59 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653839189738
:END:
*** Front
how to user ~instanceof~ statement in java?
*** Back
#+begin_src java
if ( number instanceof Int )
#+end_src
** 2022.05.30-12:00:59 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905952912
:END:
*** Front
between each concept like
1. function
2. import group
3. class
4. loop
5. condition
should be one ...
*** Back
blank line
** 2022.05.30-12:03:49 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905952988
:END:
*** Front
what is *vertical openness* ?
*** Back
it's where *blank lines* separate *group of lines* like functions, classes, loops or if statements etc.
** 2022.05.30-12:13:37 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953062
:END:
*** Front
concepts that are closely related should be kept ... to each other
*** Back
vertically close
** 2022.05.30-12:14:51 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953138
:END:
*** Front
closely related concepts should not be separated into ...
*** Back
different files
** 2022.05.30-12:15:38 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953212
:END:
*** Front
*protected variables* should be ...
*** Back
avoided
** 2022.05.30-12:22:12 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953287
:END:
*** Front
variables should be declared as close to their ... as possible
*** Back
usage
** 2022.05.30-12:23:15 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953362
:END:
*** Front
where *loop counters* should be declared?
*** Back
*inside* the loop itself!
** 2022.05.30-12:31:49 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953438
:END:
*** Front
If one function calls another, they should be ...,
and the caller should be ... the callee, if it's not C, C++.
*** Back
1. vertically close
2. above
** 2022.05.30-21:18:15 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937651794
:END:
*** Front
what is the *maximum limit of character per line* should be?
*** Back
120 (Uncle Bob does like that)
** 2022.05.30-21:23:34 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937651871
:END:
*** Front
assignments operator (=) should contain ... at both sides
*** Back
white spaces
** 2022.05.30-21:26:34 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937651944
:END:
*** Front
how to emphasize *operator precendence* in the code?
*** Back
use white spaces for *lower precencede* operators
#+begin_src python
b*b - 4*a*c # factors have no white space because they are high precencede
#+end_src
** 2022.05.30-21:39:40 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937652044
:END:
*** Front
how *curly braces* should be expanded?
*** Back
#+begin_src c
void like {
    this;
}
#+end_src
** 2022.05.30-22:04:00 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937652119
:END:
*** Front
what do you do if you create class methods just for *increase readability* and *do not want to provide* these methods to the users of this class?
*** Back
I put them under ~private~ scope
** 2022.05.30-22:09:31 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653938382220
:END:
*** Front
should *variable declerations* and *for*, *if* blocks contain *white spaces* in between?
*** Back
No. white spaces should only be between methods
** 2022.05.31-10:21:11 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000911881
:END:
*** Front
Objects hide their ... behind ... and expose ... that operate on that ... . Data structure expose their ... and have no meaningful ...
*** Back
1. data
2. abstractions
3. functions
4. data
5. data
6. functions
** 2022.05.31-11:50:48 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000911981
:END:
*** Front
where ~final~ keyword should be placed? *before* the type name or *after* the type name?
*** Back
behind.
#+begin_src java
public final double PI = 3.1415;
#+end_src
** 2022.05.31-12:12:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000912055
:END:
*** Front
what's the main reason that *error codes* exist?
*** Back
because in the past, there was no languages that support *exceptions* like C
** 2022.05.31-13:12:56 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000912130
:END:
*** Front
it is better to ... the *logic* and *exceptions* in different ...
*** Back
1. separate
2. functions
** 2022.05.31-13:15:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000912205
:END:
*** Front
when you write functions/methods write ... first
*** Back
1. try/catch
** 2022.05.31-21:44:01 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635123
:END:
*** Front
what TDD wants us to do first?
*** Back
write *tests* first. before *production code*
** 2022.05.31-21:52:55 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635199
:END:
*** Front
old tests can ... once the production code evolves. thus you also need to ... tests
*** Back
1. fail
2. maintain
** 2022.05.31-21:54:45 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635274
:END:
*** Front
if you have *tests* you do not fear making ... to the code!
*** Back
1. changes
** 2022.05.31-21:58:00 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635348
:END:
*** Front
what makes code *flexible*, *maintainable* and *reusable*?
*** Back
unit tests
** 2022.05.31-21:59:23 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635423
:END:
*** Front
without *tests* every *change* is a potential ...
*** Back
1. bug
** 2022.05.31-22:01:26 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635498
:END:
*** Front
the higher your ..., the less you fear.
*** Back
1. test coverage
** 2022.05.31-22:02:43 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635573
:END:
*** Front
tests enable ...
*** Back
1. change
** 2022.05.31-22:08:44 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635648
:END:
*** Front
if you don't *maintain* your tests, they get ... and one day you might ... all your tests.
*** Back
1. old
2. lose
** 2022.05.31-22:10:56 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635724
:END:
*** Front
what makes tests *clean*?
*** Back
readability, readability and readability
** 2022.06.01-09:06:48 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070111654
:END:
*** Front
which software pattern is used for writing *tests*?
*** Back
BUILD-OPERATE-CHECK pattern
** 2022.06.01-09:08:54 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070111780
:END:
*** Front
explain 3 steps of *Build-Operate-Check* pattern
*** Back
The first part *builds up the test data*, the second part *operates on that test data*, and the third part *checks* that the operation yielded the expected results.
** 2022.06.01-09:34:41 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070111904
:END:
*** Front
how to tell java that the following method is a *test*?
*** Back
put ~@Test~ above the method
** 2022.06.01-09:45:16 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112028
:END:
*** Front
what the following code represents?
#+begin_src java
@Test
public void turnOnHeaterAndBlowerIfTooCold() throws Exception {
    tooCold();
    assertEquals("HBchl", hw.getState());
}
#+end_src
*** Back
this is a *test* code written for java using JUnit
** 2022.06.01-09:49:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112153
:END:
*** Front
tell me which phase the ~tooCold()~ function in *build-operate-check* pattern?
#+begin_src java
@Test
public void turnOnHeaterAndBlowerIfTooCold() throws Exception {
    tooCold();
    assertEquals("HBchl", hw.getState());
}
#+end_src
*** Back
build
** 2022.06.01-09:51:20 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112279
:END:
*** Front
which phase the ~assertEquals~ method is inside *build-operate-check* pattern?
#+begin_src java
@Test
public void turnOnHeaterAndBlowerIfTooCold() throws Exception {
    tooCold();
    assertEquals("HBchl", hw.getState());
}
#+end_src
*** Back
check
** 2022.06.01-09:55:13 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112403
:END:
*** Front
which phase ~hs.getState()~ function is inside *build-operate-check* pattern?
#+begin_src java
@Test
public void turnOnHeaterAndBlowerIfTooCold() throws Exception {
    tooCold();
    assertEquals("HBchl", hw.getState());
}
#+end_src
*** Back
operate
** 2022.06.01-09:57:53 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112552
:END:
*** Front
remember this code from *clean code*? what it represents?
#+begin_src java
public String getState() {
String state = "";
state += heater ? "H" : "h";
state += blower ? "B" : "b";
state += cooler ? "C" : "c";
state += hiTempAlarm ? "H" : "h";
state += loTempAlarm ? "L" : "l";
return state;
}
#+end_src
*** Back
it's the code behind ~getState()~ function that is used in tests.
** 2022.06.01-09:59:57 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112653
:END:
*** Front
production code might run in a very constrained environment where resources are limited. however the test environment is ... that ... at all.
*** Back
1. not
2. constrained
** 2022.06.01-10:02:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112778
:END:
*** Front
what *Dual Standard* means in software engineering?
*** Back
it's where production and test environments are different. we can do more resource intensive things in test environments while can't in production code.
** 2022.06.01-10:13:54 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112903
:END:
*** Front
multiple assertions inside a test is ...
*** Back
1. allowed. but try to minimize
** 2022.06.01-10:16:59 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070113029
:END:
*** Front
what *prefix* word all test functions must contain?
*** Back
~test~
** 2022.06.01-12:48:39 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080190631
:END:
*** Front
for which area in software engineering the *F.I.R.S.T.* princible is used?
*** Back
testing
** 2022.06.01-12:49:44 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080190772
:END:
*** Front
*F* in FIRST princible:
Tests should be .... They should ... quickly. When tests run slow, you won’t want to run them .... If you don’t run them ..., you won’t find ... early enough to fix them easily. You won’t feel as free to clean up the code. Eventually the code will begin to ....
*** Back
1. fast
2. run
3. frequently
4. frequently
5. problems
6. rot
** 2022.06.01-12:56:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080190933
:END:
*** Front
*I* in FIRST princible:
... Tests should not depend on .... . One test should not set up the conditions for the .... . You should be able to run each test ... and run the tests in any order you like.
*** Back
1. independent
2. each other
3. next test
4. independently
** 2022.06.01-13:01:17 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080191063
:END:
*** Front
*R* in FIRST princible:
... Tests should be ... in any environment. You should be able to run the
tests in the .... , in the .... , and on your laptop while
riding home on the train without a network.
*** Back
1. repeatable
2. production environment
3. QA environment
** 2022.06.01-13:09:00 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080191218
:END:
*** Front
*unit tests* provide 3 ability for the production code. what are they?
*** Back
1. flexibility
2. reusability
3. maintainability
** 2022.06.01-13:11:05 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080191403
:END:
*** Front
*S* in FIRST princible:
... The tests should have a ... output. Either they ... or ... . You should not have to read through a log file to tell whether the tests pass. You should not have to manually compare two different text files to see whether the tests pass. If the tests aren’t self-validating, then failure can become ... and running the tests can require a long ... evaluation.
*** Back
1. self-validating
2. boolean
3. pass
4. fail
5. subjective
6. manual
** 2022.06.01-13:33:25 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080191628
:END:
*** Front
*T* in FIRST princible:
... The tests need to be written in a ... fashion. Unit tests should be written just before the ... that makes them pass. If you write tests after the production code, then you may find the production code to be ... . You may decide that some production code is too ... to test. You may not design the production code to be ... .
*** Back
1. timely
2. timely
3. production code
4. hard to test
5. hard
6. testable
** 2022.06.01-13:50:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654082376980
:END:
*** Front
what should come first in the *class*?
*** Back
list of variables
** 2022.06.01-13:52:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654082377056
:END:
*** Front
a class should begin with a list of ...
*** Back
1. variables
** 2022.06.01-13:52:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654082377130
:END:
*** Front
~public static~ constatnts should come ... when declaring list of variables inside a class
*** Back
1. first
** 2022.06.01-14:30:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089339668
:END:
*** Front
what is the *order of list of variables* should be when creating classes?
*** Back
1. ~public static~ *constants* variables
2. ~private static~ variables
3. ~private~ *instance* (class) variables
** 2022.06.01-14:38:23 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089339913
:END:
*** Front
avoid public ... properties!
*** Back
1. class
** 2022.06.01-14:42:28 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089340087
:END:
*** Front
why do we need to avoid ~public~ variables in classes?
*** Back
because only class itself have to have *the right* to modify it's properties.
** 2022.06.01-15:00:16 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089340255
:END:
*** Front
when creating classes what shold follow after *list of variables*?
*** Back
public functions/methods
** 2022.06.01-15:53:36 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089340486
:END:
*** Front
how *clean classes* should look? (declaration order)
*** Back
#+begin_src java
public class MeaningfulNounName() {
    /* public static constants */
    /* private static variables */
    /* private variables */
    /* public methods that follows step down rule */
}
#+end_src
** 2022.06.01-16:12:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089340667
:END:
*** Front
what *encapsulation* means for classes?
*** Back
classes should not expose their *properties* and *utility functions* to the ouside world.
** 2022.06.01-16:14:20 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089340869
:END:
*** Front
The ﬁfirst rule of classes is that they should be ... . The second rule of classes is that they should be .... .
*** Back
1. small
2. smaller than that
** 2022.06.01-16:37:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654090983555
:END:
*** Front
With functions we measured size by counting physical lines. With classes we use a
different measure. We count ...
*** Back
1. responsibilities
** 2022.06.02-09:50:05 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156124723
:END:
*** Front
what *utility functions* do in terms of OO?
*** Back
help to increase *readability* of *public functions*
** 2022.06.02-09:53:19 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156124797
:END:
*** Front
why *utility methods* shold be *private*?
*** Back
because they only *provide readability of public functions* and users of the class *are not suppose to see them*
** 2022.06.02-09:56:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156124871
:END:
*** Front
what *utility methods* hide from the user?
*** Back
implementation that makes code *hard to read*
** 2022.06.02-10:12:09 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156124947
:END:
*** Front
"ambiguous" in Turkish?
*** Back
belirsiz
** 2022.06.02-10:14:43 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125021
:END:
*** Front
if you can't find a *simple name* for a *class* then which problem the class has?
*** Back
class is *too large*
** 2022.06.02-10:17:27 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125097
:END:
*** Front
finding a *descriptive name* for a class becomes easier for ... classes
*** Back
smaller
** 2022.06.02-10:23:22 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125171
:END:
*** Front
how can you tell if the class violates *SRP* just *by looking*?
*** Back
if class is *vertically long* then it violates
** 2022.06.02-10:27:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125247
:END:
*** Front
the name of a class shold describe what ... if fulfills
*** Back
1. resposibilities
** 2022.06.02-10:29:40 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125322
:END:
*** Front
which *words* in class names are *heralds of SRP violating classes*?
*** Back
weasel words like *Processor*, *Manager*, *Super*
** 2022.06.02-10:36:59 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125396
:END:
*** Front
when writing *briefs* or *TO* strings what words should we avoid?
*** Back
*if*, *or*, *and*
** 2022.06.02-10:38:31 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125473
:END:
*** Front
what SOLID principle the class violates if it has words like *if*, *and*, *or* in its *brief*?
*** Back
it violates SRP
** 2022.06.02-10:40:44 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125571
:END:
*** Front
how can we heal *classes which violate SRP*? (step by step)
*** Back
1. read or rewrite the *brief* for the class
2. see if it contains ~special words~ like *and*, *or*, *if* in the *brief*
3. *divide the class* for every special word and *create new classes*
4. *populate newly created class briefs* with sub sentences between special words
** 2022.06.02-11:26:38 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:END:
*** Front
why having *lots of small classes* in the system is a good idea?
*** Back
because it lets the system to be *organized* and *flexible*
* ros1 flashcards
* java
** 2022.05.31-09:39:08 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653979212835
:END:
*** Front
what ~final~ keyword represents when using with *variables*?
*** Back
constant variable
* vocabulary
