#+title: Anki
#+startup: content

left at page 77, "the newspaper metaphor"
* notitia
** 20:17
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653758959208
:END:
*** Front
if a *name* of a variable, class or function _needs a comment_ then the name does not reveal its ...
*** Back
intent
** 20:25
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653758959306
:END:
*** Front
why including the word "list" in a variable name is a bad thing?
*** Back
because people might assume that this is actually a *list* or *array* object.
** 20:27
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653758959405
:END:
*** Front
which alternative word should be used instead *list* in an object name?
*** Back
if it's not actually a list or array, use *group* or use "s" to represent quantity
** 20:48 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653760554056
:END:
*** Front
which 2 words should be used when we use variables for *copying* or *moving* from one directoion to another
*** Back
*source* and *destination*
** 20:54 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653760554161
:END:
*** Front
why using *pronounceable* names important?
*** Back
because *pronouncing*, *discussing* about this variable will be easier. also *searching* is easier.
** 21:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653761082931
:END:
*** Front
why using *encodings* like *Hungarian Notation* is a bad idea?
*** Back
because it add a *metal load* to the code. programmer will need to _decipher_ every variable name. also *searching* is *hard*. and *miss spelling* them is easy!
** 21:07 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
how to reference class properties in java?
*** Back
#+begin_src java
this.your_property
#+end_src
** 22:19 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766195648
:END:
*** Front
is including *verb* words inside *class names* good idea?
*** Back
No. It should be *noun*
** 22:23 :programming:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766195749
:END:
*** Front
what *predicate method* means in programming?
*** Back
methods that return *boolean* like ~true~ or ~false~
** 22:27 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766195823
:END:
*** Front
how *predicate methods* should be named?
*** Back
~isEven()~, ~isEmpty()~ and so on.
** 22:32 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766561148
:END:
*** Front
what is *accessor method* means?
*** Back
it accesses a *property* of a class
** 22:33 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766561223
:END:
*** Front
what *mutator method* means?
*** Back
it mutates (changes) a *property or a class*
** 22:34 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766561323
:END:
*** Front
how *mutator methods* should be names?
*** Back
use ~set~ prefix. like ~setName("savolla")~
** 22:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766561398
:END:
*** Front
how *accessor methods* should be names?
*** Back
use ~get~ prefix. like ~getName()~
** 22:37 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018124
:END:
*** Front
what is *static factory* methods?
*** Back
TODO
** 22:58 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018199
:END:
*** Front
what is *punning* in coding?
*** Back
it's where you use words which has *multiple meanings*. like ~add()~. where it can be understood as *summing* or *inserting*
** 23:01 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018273
:END:
*** Front
what is the better word alternative than *add* when you adding some element to an *array* or *list*?
*** Back
*append*
** 23:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018349
:END:
*** Front
what is the better word alternative than *add* when you _summing values_?
*** Back
~sum~
** 23:05 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018423
:END:
*** Front
what is *visitor pattern*?
*** Back
TODO
** 23:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018499
:END:
*** Front
is using *problem domain concept names* as variable,class names a good idea?
*** Back
yes.
** 2022.05.29-12:50:25 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653818626939
:END:
*** Front
what is the smallest thing of organization in programs?
*** Back
functions
** 2022.05.29-12:52:52 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653818627039
:END:
*** Front
how boolean type is represented in java?
*** Back
~boolean~
** 2022.05.29-12:59:16 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653818627138
:END:
*** Front
what is *JUnit*?
*** Back
it's a *testing framework* for *Java*
** 2022.05.29-13:02:45 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653818627238
:END:
*** Front
the first rule of functions is that *they should be small* the second rule of functions is that ...
*** Back
they should be smaller that that!
** 2022.05.29-13:08:59 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773362
:END:
*** Front
how many *lines* should ~if~, ~else~, ~else if~, ~for~ or ~while~ blocks contain?
*** Back
just 1 line!
** 2022.05.29-13:11:38 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773462
:END:
*** Front
why code blocks (if, else, for, while) should contain just 1 line?
*** Back
1. they add *documentational* value
2. it makes code very *readable*
** 2022.05.29-13:13:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773565
:END:
*** Front
code block should only contain 1 line of code. what that one line would be?
*** Back
it's a function call!
** 2022.05.29-13:16:31 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773663
:END:
*** Front
what is the maximum *indent level* of a function?
*** Back
just one!! (or maybe 2)
** 2022.05.29-13:17:27 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773762
:END:
*** Front
why maximum indentation level of function blocks should be only 1?
*** Back
it makes code very easy to read and understand
** 2022.05.29-13:20:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773862
:END:
*** Front
functions should do ... and they should do it ...
*** Back
1. one thing
2. well
** 2022.05.29-13:24:47 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773938
:END:
*** Front
how to write a *docstring* for a function?
*** Back
1. use the word "TO" as a prefix to the *function name*
2. if function name is in a *verbal* form then it will be more easier to describe it
3. for example "To renderPageWithSetups we first create page and then add setups" is a very nice example of a docstring
** 2022.05.29-13:29:56 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820774012
:END:
*** Front
how to understand if a function is doing *more than one thing*?
*** Back
we write a *docstring* using *TO* prefix and see if we have multiple tasks inside a function
** 2022.05.29-13:47:36 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119013
:END:
*** Front
what is *stepdown rule*?
*** Back
reading the program by *descending* one level of abstraction at a time
** 2022.05.29-13:55:10 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119088
:END:
*** Front
how do we make applying *stepdown rule* more easily?
*** Back
by using *TO* paragraphs as *docstrings*.
** 2022.05.29-14:05:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119188
:END:
*** Front
what is *abstract factory*?
*** Back
TODO
** 2022.05.29-14:06:11 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119287
:END:
*** Front
which SOLID principle does *switch* statements brake?
*** Back
1. SRP (single responsibility principle)
2. OCP (open close principle)
** 2022.05.29-14:07:15 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119362
:END:
*** Front
how to deal with *switch statements* in terms of *clean code*?
*** Back
put it behind an *Abstract Factory*
** 2022.05.29-14:09:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119437
:END:
*** Front
when *switch statements* can be tolerated and not creating an *abstract factory* for them?
*** Back
if they appear *only once* in the code.
** 2022.05.29-14:11:25 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119538
:END:
*** Front
write a code example of *implementing* an *interface* in java
*** Back
#+begin_src java
public class A implements B {
    ...
}
#+end_src
** 2022.05.29-14:14:17 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119612
:END:
*** Front
which *postfix* should be used in the name of class if it *implements* some interface?
*** Back
~Impl~.
Example: ~public class EmployeeFactoryImpl implements EmployeeFactory {~
** 2022.05.29-14:17:24 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119687
:END:
*** Front
#+begin_quote
you know you are working on ... when each routine turns out to be pretty much what you ...
#+end_quote

*** Back
1. clena code
2. expected
** 2022.05.29-14:29:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598198
:END:
*** Front
a *long* descriptive name is better than a ... . a long descriptive name is better than a ...
*** Back
1. *short cryptic* name
2. long descriptive *comment*
** 2022.05.29-14:33:04 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598293
:END:
*** Front
is spending time to find a good variable, class or function name a good idea?
*** Back
definitely yes!
** 2022.05.29-14:34:40 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598471
:END:
*** Front
what benefit can *choosing descriptive names* bring to your module, class or function?
*** Back
1. better understanding of the module
2. can help to *improve* the module by *favorable redesigning*
** 2022.05.29-14:39:00 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598590
:END:
*** Front
what *niladic* function means?
*** Back
function with *zero arguments*
** 2022.05.29-14:40:12 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598799
:END:
*** Front
what *monadic function* means?
*** Back
function with *only one* parameter
** 2022.05.29-14:40:48 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598894
:END:
*** Front
what *dyadic function* means?
*** Back
function with *two parameters*
** 2022.05.29-14:41:20 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598966
:END:
*** Front
what *triadic function* means?
*** Back
function with *three arguments*
** 2022.05.29-14:41:58 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824599043
:END:
*** Front
what *polyadic function* means?
*** Back
function with *more than three parameters*
** 2022.05.29-14:54:17 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708537
:END:
*** Front
you should avoid more than ... function arguments
*** Back
2
** 2022.05.29-14:57:52 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708612
:END:
*** Front
what is the biggest reason why we have to avoid too much function arguments ?
*** Back
*testing* becomes harder when arguments increase
** 2022.05.29-15:15:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708688
:END:
*** Front
what are the 3 forms of *monadic functions*?
*** Back
1. question monads
2. operator monads
3. event monads
** 2022.05.29-15:16:41 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708763
:END:
*** Front
*question monadic functions* include ... word as prefix and returns a ... value. they ... mutate the argument
*** Back
1. "is"
2. boolean
3. do not
** 2022.05.29-15:18:18 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708838
:END:
*** Front
*operator monadic functions* ... the input argument and returns the ... version
*** Back
1. transforms
2. modified
** 2022.05.29-15:21:13 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708912
:END:
*** Front
what is *event monadic function* ?
*** Back
alters the *state of the system* and does not return anything
** 2022.05.29-15:24:54 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708987
:END:
*** Front
why passing *booleans* as parameters to a function is a *bad idea*?
*** Back
because it's clear that this function *does more than one thing*. one for ~true~ value and one for ~false~ value.
** 2022.05.29-15:27:01 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709062
:END:
*** Front
how to heal functions that take *booleans* as parameter?
*** Back
create two separate functions. one for ~true~ value and another for ~false~ value
** 2022.05.29-15:35:07 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709138
:END:
*** Front
what should we do if function has to take more than 2 arguments and arguments inside are a part of concept (like x,y,z values of a 3D point)?
*** Back
create a special *struct* or *class* for these arguments (like class Point) and pass the new *class object* instead
** 2022.05.29-15:40:55 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709238
:END:
*** Front
*dyadic functions* require us to remember *the order of arguments*. how can we solve this small issue?
*** Back
by putting the order inside the name of the function.
#+begin_src java
assert(expected, actual)
#+end_src
becomes
#+begin_src java
assertExpectedEqualsActual(expected, actual)
#+end_src
** 2022.05.29-15:48:19 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709313
:END:
*** Front
what is *side effects* of a function?
*** Back
when function modifies things that are not inside its scope.
** 2022.05.29-15:50:13 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709388
:END:
*** Front
give examples of *side effects* of functions
*** Back
1. global variable modification
2. class attribute modification
3. initializing and using other classes
** 2022.05.29-16:08:27 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653830475287
:END:
*** Front
what can we do to avoid *output function arguments*?
*** Back
use OO. output arguments can be used as class objects
#+begin_src python
negate(number) # don't do this
number.negate() # do this!
#+end_src
** 2022.05.29-16:20:22 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653830475363
:END:
*** Front
use ... instead of using *error codes in if statements*
*** Back
try / catch blocks
** 2022.05.29-17:16:16 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264438
:END:
*** Front
how many lines should *try/catch* blocks contain?
*** Back
only 1
** 2022.05.29-17:17:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264513
:END:
*** Front
what *catch* blocks should contain?
*** Back
function call
** 2022.05.29-17:17:49 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264588
:END:
*** Front
which *postfix* should be used for the function that is being called inside a *catch* block?
*** Back
~Error~
** 2022.05.29-17:28:21 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264688
:END:
*** Front
what are the rules of *structured programming*?
*** Back
1. functions contain only one ~return~ statement
2. no ~break~ or ~continue~ statements in a loop
3. never use ~goto~ statements
** 2022.05.29-17:32:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264763
:ANKI_FAILURE_REASON: Note was not found: 1653835264763
:END:
*** Front
how to write functions like Uncle Bob suggests in his *Clean Code* book?
*** Back
1. write the function without any prettifying
** 2022.05.29-17:35:57 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264838
:END:
*** Front
what are the steps for refining a function? (massaging the code)
*** Back
1. reduce number of *indenting*
2. fix *nested loops*
3. shorten *argument list*
4. find *better names*
5. remove *duplicated code*
** 2022.05.29-18:23:21 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653839189463
:END:
*** Front
why *comments* are liers?
*** Back
because programmers update the code below and usually forget to update the comments above
** 2022.05.29-18:25:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653839189538
:END:
*** Front
instead of writing *comments* you better express yourself better in the ...
*** Back
1. code
** 2022.05.29-18:35:32 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653839189638
:END:
*** Front
what is the java statement for testing an object if it's an instance of a particular class
*** Back
~instanceof~
** 2022.05.29-18:36:59 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653839189738
:END:
*** Front
how to user ~instanceof~ statement in java?
*** Back
#+begin_src java
if ( number instanceof Int )
#+end_src
** 2022.05.30-12:00:59 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905952912
:END:
*** Front
between each concept like
1. function
2. import group
3. class
4. loop
5. condition
should be one ...
*** Back
blank line
** 2022.05.30-12:03:49 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905952988
:END:
*** Front
what is *vertical openness* ?
*** Back
it's where *blank lines* separate *group of lines* like functions, classes, loops or if statements etc.
** 2022.05.30-12:13:37 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953062
:END:
*** Front
concepts that are closely related should be kept ... to each other
*** Back
vertically close
** 2022.05.30-12:14:51 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953138
:END:
*** Front
closely related concepts should not be separated into ...
*** Back
different files
** 2022.05.30-12:15:38 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953212
:END:
*** Front
*protected variables* should be ...
*** Back
avoided
** 2022.05.30-12:22:12 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953287
:END:
*** Front
variables should be declared as close to their ... as possible
*** Back
usage
** 2022.05.30-12:23:15 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953362
:END:
*** Front
where *loop counters* should be declared?
*** Back
*inside* the loop itself!
** 2022.05.30-12:31:49 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953438
:END:
*** Front
If one function calls another, they should be ...,
and the caller should be ... the callee, if it's not C, C++.
*** Back
1. vertically close
2. above
** 2022.05.30-21:18:15 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937651794
:END:
*** Front
what is the *maximum limit of character per line* should be?
*** Back
120 (Uncle Bob does like that)
** 2022.05.30-21:23:34 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937651871
:END:
*** Front
assignments operator (=) should contain ... at both sides
*** Back
white spaces
** 2022.05.30-21:26:34 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937651944
:END:
*** Front
how to emphasize *operator precendence* in the code?
*** Back
use white spaces for *lower precencede* operators
#+begin_src python
b*b - 4*a*c # factors have no white space because they are high precencede
#+end_src
** 2022.05.30-21:39:40 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937652044
:END:
*** Front
how *curly braces* should be expanded?
*** Back
#+begin_src c
void like {
    this;
}
#+end_src
** 2022.05.30-22:04:00 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937652119
:END:
*** Front
what do you do if you create class methods just for *increase readability* and *do not want to provide* these methods to the users of this class?
*** Back
I put them under ~private~ scope
** 2022.05.30-22:09:31 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653938382220
:END:
*** Front
should *variable declerations* and *for*, *if* blocks contain *white spaces* in between?
*** Back
No. white spaces should only be between methods
** 2022.05.31-10:21:11 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000911881
:END:
*** Front
Objects hide their ... behind ... and expose ... that operate on that ... . Data structure expose their ... and have no meaningful ...
*** Back
1. data
2. abstractions
3. functions
4. data
5. data
6. functions
** 2022.05.31-11:50:48 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000911981
:END:
*** Front
where ~final~ keyword should be placed? *before* the type name or *after* the type name?
*** Back
behind.
#+begin_src java
public final double PI = 3.1415;
#+end_src
** 2022.05.31-12:12:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000912055
:END:
*** Front
what's the main reason that *error codes* exist?
*** Back
because in the past, there was no languages that support *exceptions* like C
** 2022.05.31-13:12:56 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000912130
:END:
*** Front
it is better to ... the *logic* and *exceptions* in different ...
*** Back
1. separate
2. functions
** 2022.05.31-13:15:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000912205
:END:
*** Front
when you write functions/methods write ... first
*** Back
1. try/catch
** 2022.05.31-21:44:01 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:END:
*** Front
what TDD wants us to do first?
*** Back
write *tests* first. before *production code*
** 2022.05.31-21:52:55 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:END:
*** Front
old tests can ... once the production code evolves. thus you also need to ... tests
*** Back
1. fail
2. maintain
** 2022.05.31-21:54:45 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:END:
*** Front
if you have *tests* you do not fear making ... to the code!
*** Back
1. changes
** 2022.05.31-21:58:00 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:END:
*** Front
what makes code *flexible*, *maintainable* and *reusable*?
*** Back
unit tests
* ros1 flashcards
* java
** 2022.05.31-09:39:08 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653979212835
:END:
*** Front
what ~final~ keyword represents when using with *variables*?
*** Back
constant variable
