#+title: Anki
#+startup: content

* notitia
** 2022.06.08-15:23:52 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:END:
*** Front
in RL *epoch* is also referred to?
*** Back
time step
** 2022.06.08-16:12:20 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:END:
*** Front
in RL we need to aknowledge the agent that *getting the reward as soon as possible* is better. we do it with ...
*** Back
discount factor / gamma
** 2022.06.08-16:14:24 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:END:
*** Front
what's the *discount factor*'s second name?
*** Back
gamma
** 2022.06.08-16:15:00 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:END:
*** Front
what is *gamma* in RL?
*** Back
discount factor that makes rewards more valuable at starting phase
* ros1 flashcards
* java
** 2022.05.31-09:39:08 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653979212835
:END:
*** Front
what ~final~ keyword represents when using with *variables*?
*** Back
constant variable
* vocabulary
* uploaded
** 20:48 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653760554056
:END:
*** Front
which 2 words should be used when we use variables for *copying* or *moving* from one directoion to another
*** Back
*source* and *destination*
** 20:54 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653760554161
:END:
*** Front
why using *pronounceable* names important?
*** Back
because *pronouncing*, *discussing* about this variable will be easier. also *searching* is easier.
** 21:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653761082931
:END:
*** Front
why using *encodings* like *Hungarian Notation* is a bad idea?
*** Back
because it add a *metal load* to the code. programmer will need to _decipher_ every variable name. also *searching* is *hard*. and *miss spelling* them is easy!
** 21:07 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
how to reference class properties in java?
*** Back
#+begin_src java
this.your_property
#+end_src
** 22:19 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766195648
:END:
*** Front
is including *verb* words inside *class names* good idea?
*** Back
No. It should be *noun*
** 22:23 :programming:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766195749
:END:
*** Front
what *predicate method* means in programming?
*** Back
methods that return *boolean* like ~true~ or ~false~
** 22:27 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766195823
:END:
*** Front
how *predicate methods* should be named?
*** Back
~isEven()~, ~isEmpty()~ and so on.
** 22:32 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766561148
:END:
*** Front
what is *accessor method* means?
*** Back
it accesses a *property* of a class
** 22:33 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766561223
:END:
*** Front
what *mutator method* means?
*** Back
it mutates (changes) a *property or a class*
** 22:34 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766561323
:END:
*** Front
how *mutator methods* should be names?
*** Back
use ~set~ prefix. like ~setName("savolla")~
** 22:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653766561398
:END:
*** Front
how *accessor methods* should be names?
*** Back
use ~get~ prefix. like ~getName()~
** 22:37 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018124
:END:
*** Front
what is *static factory* methods?
*** Back
TODO
** 22:58 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018199
:END:
*** Front
what is *punning* in coding?
*** Back
it's where you use words which has *multiple meanings*. like ~add()~. where it can be understood as *summing* or *inserting*
** 23:01 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018273
:END:
*** Front
what is the better word alternative than *add* when you adding some element to an *array* or *list*?
*** Back
*append*
** 23:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018349
:END:
*** Front
what is the better word alternative than *add* when you _summing values_?
*** Back
~sum~
** 23:05 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018423
:END:
*** Front
what is *visitor pattern*?
*** Back
TODO
** 23:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653769018499
:END:
*** Front
is using *problem domain concept names* as variable,class names a good idea?
*** Back
yes.
** 2022.05.29-12:50:25 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653818626939
:END:
*** Front
what is the smallest thing of organization in programs?
*** Back
functions
** 2022.05.29-12:52:52 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653818627039
:END:
*** Front
how boolean type is represented in java?
*** Back
~boolean~
** 2022.05.29-12:59:16 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653818627138
:END:
*** Front
what is *JUnit*?
*** Back
it's a *testing framework* for *Java*
** 2022.05.29-13:02:45 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653818627238
:END:
*** Front
the first rule of functions is that *they should be small* the second rule of functions is that ...
*** Back
they should be smaller that that!
** 2022.05.29-13:08:59 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773362
:END:
*** Front
how many *lines* should ~if~, ~else~, ~else if~, ~for~ or ~while~ blocks contain?
*** Back
just 1 line!
** 2022.05.29-13:11:38 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773462
:END:
*** Front
why code blocks (if, else, for, while) should contain just 1 line?
*** Back
1. they add *documentational* value
2. it makes code very *readable*
** 2022.05.29-13:13:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773565
:END:
*** Front
code block should only contain 1 line of code. what that one line would be?
*** Back
it's a function call!
** 2022.05.29-13:16:31 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773663
:END:
*** Front
what is the maximum *indent level* of a function?
*** Back
just one!! (or maybe 2)
** 2022.05.29-13:17:27 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773762
:END:
*** Front
why maximum indentation level of function blocks should be only 1?
*** Back
it makes code very easy to read and understand
** 2022.05.29-13:20:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773862
:END:
*** Front
functions should do ... and they should do it ...
*** Back
1. one thing
2. well
** 2022.05.29-13:24:47 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820773938
:END:
*** Front
how to write a *docstring* for a function?
*** Back
1. use the word "TO" as a prefix to the *function name*
2. if function name is in a *verbal* form then it will be more easier to describe it
3. for example "To renderPageWithSetups we first create page and then add setups" is a very nice example of a docstring
** 2022.05.29-13:29:56 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653820774012
:END:
*** Front
how to understand if a function is doing *more than one thing*?
*** Back
we write a *docstring* using *TO* prefix and see if we have multiple tasks inside a function
** 2022.05.29-13:47:36 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119013
:END:
*** Front
what is *stepdown rule*?
*** Back
reading the program by *descending* one level of abstraction at a time
** 2022.05.29-13:55:10 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119088
:END:
*** Front
how do we make applying *stepdown rule* more easily?
*** Back
by using *TO* paragraphs as *docstrings*.
** 2022.05.29-14:05:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119188
:END:
*** Front
what is *abstract factory*?
*** Back
TODO
** 2022.05.29-14:06:11 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119287
:END:
*** Front
which SOLID principle does *switch* statements brake?
*** Back
1. SRP (single responsibility principle)
2. OCP (open close principle)
** 2022.05.29-14:07:15 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119362
:END:
*** Front
how to deal with *switch statements* in terms of *clean code*?
*** Back
put it behind an *Abstract Factory*
** 2022.05.29-14:09:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119437
:END:
*** Front
when *switch statements* can be tolerated and not creating an *abstract factory* for them?
*** Back
if they appear *only once* in the code.
** 2022.05.29-14:11:25 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119538
:END:
*** Front
write a code example of *implementing* an *interface* in java
*** Back
#+begin_src java
public class A implements B {
    ...
}
#+end_src
** 2022.05.29-14:14:17 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119612
:END:
*** Front
which *postfix* should be used in the name of class if it *implements* some interface?
*** Back
~Impl~.
Example: ~public class EmployeeFactoryImpl implements EmployeeFactory {~
** 2022.05.29-14:17:24 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653823119687
:END:
*** Front
#+begin_quote
you know you are working on ... when each routine turns out to be pretty much what you ...
#+end_quote

*** Back
1. clena code
2. expected
** 2022.05.29-14:29:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598198
:END:
*** Front
a *long* descriptive name is better than a ... . a long descriptive name is better than a ...
*** Back
1. *short cryptic* name
2. long descriptive *comment*
** 2022.05.29-14:33:04 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598293
:END:
*** Front
is spending time to find a good variable, class or function name a good idea?
*** Back
definitely yes!
** 2022.05.29-14:34:40 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598471
:END:
*** Front
what benefit can *choosing descriptive names* bring to your module, class or function?
*** Back
1. better understanding of the module
2. can help to *improve* the module by *favorable redesigning*
** 2022.05.29-14:39:00 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598590
:END:
*** Front
what *niladic* function means?
*** Back
function with *zero arguments*
** 2022.05.29-14:40:12 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598799
:END:
*** Front
what *monadic function* means?
*** Back
function with *only one* parameter
** 2022.05.29-14:40:48 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598894
:END:
*** Front
what *dyadic function* means?
*** Back
function with *two parameters*
** 2022.05.29-14:41:20 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824598966
:END:
*** Front
what *triadic function* means?
*** Back
function with *three arguments*
** 2022.05.29-14:41:58 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653824599043
:END:
*** Front
what *polyadic function* means?
*** Back
function with *more than three parameters*
** 2022.05.29-14:54:17 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708537
:END:
*** Front
you should avoid more than ... function arguments
*** Back
2
** 2022.05.29-14:57:52 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708612
:END:
*** Front
what is the biggest reason why we have to avoid too much function arguments ?
*** Back
*testing* becomes harder when arguments increase
** 2022.05.29-15:15:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708688
:END:
*** Front
what are the 3 forms of *monadic functions*?
*** Back
1. question monads
2. operator monads
3. event monads
** 2022.05.29-15:16:41 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708763
:END:
*** Front
*question monadic functions* include ... word as prefix and returns a ... value. they ... mutate the argument
*** Back
1. "is"
2. boolean
3. do not
** 2022.05.29-15:18:18 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708838
:END:
*** Front
*operator monadic functions* ... the input argument and returns the ... version
*** Back
1. transforms
2. modified
** 2022.05.29-15:21:13 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708912
:END:
*** Front
what is *event monadic function* ?
*** Back
alters the *state of the system* and does not return anything
** 2022.05.29-15:24:54 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828708987
:END:
*** Front
why passing *booleans* as parameters to a function is a *bad idea*?
*** Back
because it's clear that this function *does more than one thing*. one for ~true~ value and one for ~false~ value.
** 2022.05.29-15:27:01 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709062
:END:
*** Front
how to heal functions that take *booleans* as parameter?
*** Back
create two separate functions. one for ~true~ value and another for ~false~ value
** 2022.05.29-15:35:07 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709138
:END:
*** Front
what should we do if function has to take more than 2 arguments and arguments inside are a part of concept (like x,y,z values of a 3D point)?
*** Back
create a special *struct* or *class* for these arguments (like class Point) and pass the new *class object* instead
** 2022.05.29-15:40:55 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709238
:END:
*** Front
*dyadic functions* require us to remember *the order of arguments*. how can we solve this small issue?
*** Back
by putting the order inside the name of the function.
#+begin_src java
assert(expected, actual)
#+end_src
becomes
#+begin_src java
assertExpectedEqualsActual(expected, actual)
#+end_src
** 2022.05.29-15:48:19 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709313
:END:
*** Front
what is *side effects* of a function?
*** Back
when function modifies things that are not inside its scope.
** 2022.05.29-15:50:13 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653828709388
:END:
*** Front
give examples of *side effects* of functions
*** Back
1. global variable modification
2. class attribute modification
3. initializing and using other classes
** 2022.05.29-16:08:27 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653830475287
:END:
*** Front
what can we do to avoid *output function arguments*?
*** Back
use OO. output arguments can be used as class objects
#+begin_src python
negate(number) # don't do this
number.negate() # do this!
#+end_src
** 2022.05.29-16:20:22 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653830475363
:END:
*** Front
use ... instead of using *error codes in if statements*
*** Back
try / catch blocks
** 2022.05.29-17:16:16 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264438
:END:
*** Front
how many lines should *try/catch* blocks contain?
*** Back
only 1
** 2022.05.29-17:17:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264513
:END:
*** Front
what *catch* blocks should contain?
*** Back
function call
** 2022.05.29-17:17:49 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264588
:END:
*** Front
which *postfix* should be used for the function that is being called inside a *catch* block?
*** Back
~Error~
** 2022.05.29-17:28:21 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264688
:END:
*** Front
what are the rules of *structured programming*?
*** Back
1. functions contain only one ~return~ statement
2. no ~break~ or ~continue~ statements in a loop
3. never use ~goto~ statements
** 2022.05.29-17:32:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264763
:ANKI_FAILURE_REASON: Note was not found: 1653835264763
:END:
*** Front
how to write functions like Uncle Bob suggests in his *Clean Code* book?
*** Back
1. write the function without any prettifying
** 2022.05.29-17:35:57 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653835264838
:END:
*** Front
what are the steps for refining a function? (massaging the code)
*** Back
1. reduce number of *indenting*
2. fix *nested loops*
3. shorten *argument list*
4. find *better names*
5. remove *duplicated code*
** 2022.05.29-18:23:21 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653839189463
:END:
*** Front
why *comments* are liers?
*** Back
because programmers update the code below and usually forget to update the comments above
** 2022.05.29-18:25:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653839189538
:END:
*** Front
instead of writing *comments* you better express yourself better in the ...
*** Back
1. code
** 2022.05.29-18:35:32 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653839189638
:END:
*** Front
what is the java statement for testing an object if it's an instance of a particular class
*** Back
~instanceof~
** 2022.05.29-18:36:59 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653839189738
:END:
*** Front
how to user ~instanceof~ statement in java?
*** Back
#+begin_src java
if ( number instanceof Int )
#+end_src
** 2022.05.30-12:00:59 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905952912
:END:
*** Front
between each concept like
1. function
2. import group
3. class
4. loop
5. condition
should be one ...
*** Back
blank line
** 2022.05.30-12:03:49 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905952988
:END:
*** Front
what is *vertical openness* ?
*** Back
it's where *blank lines* separate *group of lines* like functions, classes, loops or if statements etc.
** 2022.05.30-12:13:37 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953062
:END:
*** Front
concepts that are closely related should be kept ... to each other
*** Back
vertically close
** 2022.05.30-12:14:51 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953138
:END:
*** Front
closely related concepts should not be separated into ...
*** Back
different files
** 2022.05.30-12:15:38 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953212
:END:
*** Front
*protected variables* should be ...
*** Back
avoided
** 2022.05.30-12:22:12 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953287
:END:
*** Front
variables should be declared as close to their ... as possible
*** Back
usage
** 2022.05.30-12:23:15 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953362
:END:
*** Front
where *loop counters* should be declared?
*** Back
*inside* the loop itself!
** 2022.05.30-12:31:49 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653905953438
:END:
*** Front
If one function calls another, they should be ...,
and the caller should be ... the callee, if it's not C, C++.
*** Back
1. vertically close
2. above
** 2022.05.30-21:18:15 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937651794
:END:
*** Front
what is the *maximum limit of character per line* should be?
*** Back
120 (Uncle Bob does like that)
** 2022.05.30-21:23:34 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937651871
:END:
*** Front
assignments operator (=) should contain ... at both sides
*** Back
white spaces
** 2022.05.30-21:26:34 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937651944
:END:
*** Front
how to emphasize *operator precendence* in the code?
*** Back
use white spaces for *lower precencede* operators
#+begin_src python
b*b - 4*a*c # factors have no white space because they are high precencede
#+end_src
** 2022.05.30-21:39:40 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937652044
:END:
*** Front
how *curly braces* should be expanded?
*** Back
#+begin_src c
void like {
    this;
}
#+end_src
** 2022.05.30-22:04:00 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653937652119
:END:
*** Front
what do you do if you create class methods just for *increase readability* and *do not want to provide* these methods to the users of this class?
*** Back
I put them under ~private~ scope
** 2022.05.30-22:09:31 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1653938382220
:END:
*** Front
should *variable declerations* and *for*, *if* blocks contain *white spaces* in between?
*** Back
No. white spaces should only be between methods
** 2022.05.31-10:21:11 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000911881
:END:
*** Front
Objects hide their ... behind ... and expose ... that operate on that ... . Data structure expose their ... and have no meaningful ...
*** Back
1. data
2. abstractions
3. functions
4. data
5. data
6. functions
** 2022.05.31-11:50:48 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000911981
:END:
*** Front
where ~final~ keyword should be placed? *before* the type name or *after* the type name?
*** Back
behind.
#+begin_src java
public final double PI = 3.1415;
#+end_src
** 2022.05.31-12:12:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000912055
:END:
*** Front
what's the main reason that *error codes* exist?
*** Back
because in the past, there was no languages that support *exceptions* like C
** 2022.05.31-13:12:56 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000912130
:END:
*** Front
it is better to ... the *logic* and *exceptions* in different ...
*** Back
1. separate
2. functions
** 2022.05.31-13:15:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654000912205
:END:
*** Front
when you write functions/methods write ... first
*** Back
1. try/catch
** 2022.05.31-21:44:01 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635123
:END:
*** Front
what TDD wants us to do first?
*** Back
write *tests* first. before *production code*
** 2022.05.31-21:52:55 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635199
:END:
*** Front
old tests can ... once the production code evolves. thus you also need to ... tests
*** Back
1. fail
2. maintain
** 2022.05.31-21:54:45 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635274
:END:
*** Front
if you have *tests* you do not fear making ... to the code!
*** Back
1. changes
** 2022.05.31-21:58:00 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635348
:END:
*** Front
what makes code *flexible*, *maintainable* and *reusable*?
*** Back
unit tests
** 2022.05.31-21:59:23 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635423
:END:
*** Front
without *tests* every *change* is a potential ...
*** Back
1. bug
** 2022.05.31-22:01:26 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635498
:END:
*** Front
the higher your ..., the less you fear.
*** Back
1. test coverage
** 2022.05.31-22:02:43 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635573
:END:
*** Front
tests enable ...
*** Back
1. change
** 2022.05.31-22:08:44 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635648
:END:
*** Front
if you don't *maintain* your tests, they get ... and one day you might ... all your tests.
*** Back
1. old
2. lose
** 2022.05.31-22:10:56 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654024635724
:END:
*** Front
what makes tests *clean*?
*** Back
readability, readability and readability
** 2022.06.01-09:06:48 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070111654
:END:
*** Front
which software pattern is used for writing *tests*?
*** Back
BUILD-OPERATE-CHECK pattern
** 2022.06.01-09:08:54 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070111780
:END:
*** Front
explain 3 steps of *Build-Operate-Check* pattern
*** Back
The first part *builds up the test data*, the second part *operates on that test data*, and the third part *checks* that the operation yielded the expected results.
** 2022.06.01-09:34:41 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070111904
:END:
*** Front
how to tell java that the following method is a *test*?
*** Back
put ~@Test~ above the method
** 2022.06.01-09:45:16 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112028
:END:
*** Front
what the following code represents?
#+begin_src java
@Test
public void turnOnHeaterAndBlowerIfTooCold() throws Exception {
    tooCold();
    assertEquals("HBchl", hw.getState());
}
#+end_src
*** Back
this is a *test* code written for java using JUnit
** 2022.06.01-09:49:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112153
:END:
*** Front
tell me which phase the ~tooCold()~ function in *build-operate-check* pattern?
#+begin_src java
@Test
public void turnOnHeaterAndBlowerIfTooCold() throws Exception {
    tooCold();
    assertEquals("HBchl", hw.getState());
}
#+end_src
*** Back
build
** 2022.06.01-09:51:20 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112279
:END:
*** Front
which phase the ~assertEquals~ method is inside *build-operate-check* pattern?
#+begin_src java
@Test
public void turnOnHeaterAndBlowerIfTooCold() throws Exception {
    tooCold();
    assertEquals("HBchl", hw.getState());
}
#+end_src
*** Back
check
** 2022.06.01-09:55:13 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112403
:END:
*** Front
which phase ~hs.getState()~ function is inside *build-operate-check* pattern?
#+begin_src java
@Test
public void turnOnHeaterAndBlowerIfTooCold() throws Exception {
    tooCold();
    assertEquals("HBchl", hw.getState());
}
#+end_src
*** Back
operate
** 2022.06.01-09:57:53 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112552
:END:
*** Front
remember this code from *clean code*? what it represents?
#+begin_src java
public String getState() {
String state = "";
state += heater ? "H" : "h";
state += blower ? "B" : "b";
state += cooler ? "C" : "c";
state += hiTempAlarm ? "H" : "h";
state += loTempAlarm ? "L" : "l";
return state;
}
#+end_src
*** Back
it's the code behind ~getState()~ function that is used in tests.
** 2022.06.01-09:59:57 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112653
:END:
*** Front
production code might run in a very constrained environment where resources are limited. however the test environment is ... that ... at all.
*** Back
1. not
2. constrained
** 2022.06.01-10:02:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112778
:END:
*** Front
what *Dual Standard* means in software engineering?
*** Back
it's where production and test environments are different. we can do more resource intensive things in test environments while can't in production code.
** 2022.06.01-10:13:54 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070112903
:END:
*** Front
multiple assertions inside a test is ...
*** Back
1. allowed. but try to minimize
** 2022.06.01-10:16:59 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654070113029
:END:
*** Front
what *prefix* word all test functions must contain?
*** Back
~test~
** 2022.06.01-12:48:39 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080190631
:END:
*** Front
for which area in software engineering the *F.I.R.S.T.* princible is used?
*** Back
testing
** 2022.06.01-12:49:44 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080190772
:END:
*** Front
*F* in FIRST princible:
Tests should be .... They should ... quickly. When tests run slow, you won’t want to run them .... If you don’t run them ..., you won’t find ... early enough to fix them easily. You won’t feel as free to clean up the code. Eventually the code will begin to ....
*** Back
1. fast
2. run
3. frequently
4. frequently
5. problems
6. rot
** 2022.06.01-12:56:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080190933
:END:
*** Front
*I* in FIRST princible:
... Tests should not depend on .... . One test should not set up the conditions for the .... . You should be able to run each test ... and run the tests in any order you like.
*** Back
1. independent
2. each other
3. next test
4. independently
** 2022.06.01-13:01:17 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080191063
:END:
*** Front
*R* in FIRST princible:
... Tests should be ... in any environment. You should be able to run the
tests in the .... , in the .... , and on your laptop while
riding home on the train without a network.
*** Back
1. repeatable
2. production environment
3. QA environment
** 2022.06.01-13:09:00 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080191218
:END:
*** Front
*unit tests* provide 3 ability for the production code. what are they?
*** Back
1. flexibility
2. reusability
3. maintainability
** 2022.06.01-13:11:05 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080191403
:END:
*** Front
*S* in FIRST princible:
... The tests should have a ... output. Either they ... or ... . You should not have to read through a log file to tell whether the tests pass. You should not have to manually compare two different text files to see whether the tests pass. If the tests aren’t self-validating, then failure can become ... and running the tests can require a long ... evaluation.
*** Back
1. self-validating
2. boolean
3. pass
4. fail
5. subjective
6. manual
** 2022.06.01-13:33:25 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654080191628
:END:
*** Front
*T* in FIRST princible:
... The tests need to be written in a ... fashion. Unit tests should be written just before the ... that makes them pass. If you write tests after the production code, then you may find the production code to be ... . You may decide that some production code is too ... to test. You may not design the production code to be ... .
*** Back
1. timely
2. timely
3. production code
4. hard to test
5. hard
6. testable
** 2022.06.01-13:50:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654082376980
:END:
*** Front
what should come first in the *class*?
*** Back
list of variables
** 2022.06.01-13:52:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654082377056
:END:
*** Front
a class should begin with a list of ...
*** Back
1. variables
** 2022.06.01-13:52:35 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654082377130
:END:
*** Front
~public static~ constatnts should come ... when declaring list of variables inside a class
*** Back
1. first
** 2022.06.01-14:30:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089339668
:END:
*** Front
what is the *order of list of variables* should be when creating classes?
*** Back
1. ~public static~ *constants* variables
2. ~private static~ variables
3. ~private~ *instance* (class) variables
** 2022.06.01-14:38:23 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089339913
:END:
*** Front
avoid public ... properties!
*** Back
1. class
** 2022.06.01-14:42:28 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089340087
:END:
*** Front
why do we need to avoid ~public~ variables in classes?
*** Back
because only class itself have to have *the right* to modify it's properties.
** 2022.06.01-15:00:16 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089340255
:END:
*** Front
when creating classes what shold follow after *list of variables*?
*** Back
public functions/methods
** 2022.06.01-15:53:36 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089340486
:END:
*** Front
how *clean classes* should look? (declaration order)
*** Back
#+begin_src java
public class MeaningfulNounName() {
    /* public static constants */
    /* private static variables */
    /* private variables */
    /* public methods (stepdown rule) */
    /* private utility functions */
}
#+end_src
** 2022.06.01-16:12:06 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089340667
:END:
*** Front
what *encapsulation* means for classes?
*** Back
classes should not expose their *properties* and *utility functions* to the ouside world.
** 2022.06.01-16:14:20 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654089340869
:END:
*** Front
The ﬁfirst rule of classes is that they should be ... . The second rule of classes is that they should be .... .
*** Back
1. small
2. smaller than that
** 2022.06.01-16:37:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654090983555
:END:
*** Front
With functions we measured size by counting physical lines. With classes we use a
different measure. We count ...
*** Back
1. responsibilities
** 2022.06.02-09:50:05 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156124723
:END:
*** Front
what *utility functions* do in terms of OO?
*** Back
help to increase *readability* of *public functions*
** 2022.06.02-09:53:19 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156124797
:END:
*** Front
why *utility methods* shold be *private*?
*** Back
because they only *provide readability of public functions* and users of the class *are not suppose to see them*
** 2022.06.02-09:56:02 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156124871
:END:
*** Front
what *utility methods* hide from the user?
*** Back
implementation that makes code *hard to read*
** 2022.06.02-10:12:09 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156124947
:END:
*** Front
"ambiguous" in Turkish?
*** Back
belirsiz
** 2022.06.02-10:14:43 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125021
:END:
*** Front
if you can't find a *simple name* for a *class* then which problem the class has?
*** Back
class is *too large*
** 2022.06.02-10:17:27 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125097
:END:
*** Front
finding a *descriptive name* for a class becomes easier for ... classes
*** Back
smaller
** 2022.06.02-10:23:22 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125171
:END:
*** Front
how can you tell if the class violates *SRP* just *by looking*?
*** Back
if class is *vertically long* then it violates
** 2022.06.02-10:27:08 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125247
:END:
*** Front
the name of a class shold describe what ... if fulfills
*** Back
1. resposibilities
** 2022.06.02-10:29:40 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125322
:END:
*** Front
which *words* in class names are *heralds of SRP violating classes*?
*** Back
weasel words like *Processor*, *Manager*, *Super*
** 2022.06.02-10:36:59 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125396
:END:
*** Front
when writing *briefs* or *TO* strings what words should we avoid?
*** Back
*if*, *or*, *and*
** 2022.06.02-10:38:31 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125473
:END:
*** Front
what SOLID principle the class violates if it has words like *if*, *and*, *or* in its *brief*?
*** Back
it violates SRP
** 2022.06.02-10:40:44 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654156125571
:END:
*** Front
how can we heal *classes which violate SRP*? (step by step)
*** Back
1. read or rewrite the *brief* for the class
2. see if it contains ~special words~ like *and*, *or*, *if* in the *brief*
3. *divide the class* for every special word and *create new classes*
4. *populate newly created class briefs* with sub sentences between special words
** 2022.06.02-11:26:38 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654197131380
:END:
*** Front
why having *lots of small classes* in the system is a good idea?
*** Back
because it lets the system to be *organized* and *flexible*
** 2022.06.02-14:32:01 :java:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654197131578
:END:
*** Front
write an example code which defines *linked list* in java
*** Back
#+begin_src java
List<Integer> elements = new LinkedList<Integer>();
#+end_src
** 2022.06.03-11:08:11 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654245459587
:END:
*** Front
class is ... cohesive when all of its methods ... all of it's ...
*** Back
1. fully
2. manipulate
3. properties
** 2022.06.03-11:09:03 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654245459661
:END:
*** Front
class does not have *cohesion* when any of its methods ... any of its ...
*** Back
1. manipulate
2. properties
** 2022.06.03-11:11:00 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654245459736
:END:
*** Front
we always want to ... *cohesion* in Object Oriented programming.
*** Back
1. maximize
** 2022.06.03-11:18:42 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654245459811
:END:
*** Front
how to heal classes with *low cohesion*?
*** Back
try to separate *variables* and *methods* into _new smaller classes_ that are *more cohesive*
** 2022.06.03-11:36:58 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654245459885
:END:
*** Front
*solely* in Turkish?
*** Back
yalnızca
** 2022.06.03-11:39:24 :clean_code:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
breaking a *large function* into *many smaller functions* often gives us the opportunity to split several smaller ... as well
*** Back
1. classes
** 2022.06.03-13:51:16 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
*merit* in Turkish?
*** Back
değer
** 2022.06.03-14:58:04 :design_patterns:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654258364713
:END:
*** Front
3 types of *design patterns*?
*** Back
1. creational
2. structural
3. behavioral
** 2022.06.03-15:00:16 :design_patterns:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654258364799
:END:
*** Front
what *creational design patterns* is all about?
*** Back
it's about *creating* instances of class objects
** 2022.06.03-15:07:46 :design_patterns:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654258364886
:END:
*** Front
count all *creational design patterns*
*** Back
1. factory
2. abstract factory
3. builder
4. prototype
5. singleton
** 2022.06.03-15:09:04 :design_patterns:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654258364960
:END:
*** Front
count all *structural design patterns*
*** Back
1. adapter
2. bridge
3. composite
4. decorator
5. facade
6. flyweight
7. proxy
** 2022.06.03-15:10:46 :design_patterns:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654258365036
:END:
*** Front
count all *behavioral design patterns*
*** Back
1. chain of responsibility
2. command
3. interpreter
4. iterator
5. mediator
6. memento
7. observer
8. state
9. strategy
10. template method
11. visitor
** 2022.06.03-15:37:35 :design_patterns:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654260553486
:END:
*** Front
*factory design pattern* is more _proffesional_ way of creating ... than ... operator.
*** Back
1. class objects
2. ~new()~
** 2022.06.03-15:42:07 :design_patterns:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654260553561
:END:
*** Front
in *factory pattern* you provide ... or ... to create objects
*** Back
1. interface
2. abstract class
** 2022.06.04-20:40:32 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654374745753
:END:
*** Front
*conveying* in Turkish?
*** Back
taşımak
** 2022.06.04-21:53:37 :linux:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654374745884
:END:
*** Front
structure of *while loop* in *bash*?
*** Back
#+begin_src sh
while [ condition ]
do
   command1
   command2
   command3
done
#+end_src
** 2022.06.04-22:16:50 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654374745976
:END:
*** Front
*pursule* in Turkish?
*** Back
izlemek
** 2022.06.04-23:02:02 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654374746076
:END:
*** Front
what are the 3 main branches of AI?
*** Back
1. Supervised Learning
2. Unsupervised Learning
3. Reinforcement Learning
** 2022.06.04-23:05:48 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654374746176
:END:
*** Front
*supervised learning* is the tast of learning from ... data.
*** Back
labeled
** 2022.06.04-23:07:55 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654374746276
:END:
*** Front
in *supervised learning* labeling the data is decided by ... itself
*** Back
human
** 2022.06.04-23:08:58 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654374746376
:END:
*** Front
in *supervised learning* the main goal is to ...
*** Back
generalize
** 2022.06.04-23:10:54 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654374746476
:END:
*** Front
*unsupervised learning* is the task of learning from ... data
*** Back
unlabeled
** 2022.06.04-23:13:57 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654374746576
:END:
*** Front
*reinforcement learning* is the task of learning through ... and ...
*** Back
1. trial
2. error
** 2022.06.04-23:24:52 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654374746676
:END:
*** Front
what *type* of problems *deep reinforcement learning* solves?
*** Back
complex sequential decision-making problems under uncertainty
** 2022.06.04-23:29:33 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654374746777
:END:
*** Front
in *deep reinforcement learning* an *agent* has a single role: ...
*** Back
decision making
** 2022.06.05-10:31:51 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
which variables represent *state space* in RL?
*** Back
all variables that related to *environment*
** 2022.06.05-10:32:39 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
in RL, all environment variables form ... space
*** Back
1. state
** 2022.06.05-10:36:51 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
in RL agents don’t have access to the actual full state of the environment. The part of a state that the agent can observe is called an ...
*** Back
observation space
** 2022.06.05-10:45:57 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
in RL the *agent*'s actions may change the *state* of the ...
*** Back
environment
** 2022.06.05-10:47:54 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
the *function* that maps agent's actions to environment states is called ...
*** Back
transition function
** 2022.06.05-10:49:17 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
in RL the environment may also provide a reward signal as a response to agent's behaviour. The function responsible for this mapping is called the ...
*** Back
revard function
** 2022.06.05-11:00:56 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
in RL transition and rewarf function create ...
*** Back
environment model
** 2022.06.05-11:08:03 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
in RL the *agent* has a *three-step* process
*** Back
1. interaction with environment
2. evaluates environment behaviour
3. improves depending on rewards
** 2022.06.05-11:15:09 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
The interactions between the agent and the environment go on for several cycles. Each cycle is called a ...
*** Back
time step
** 2022.06.05-11:51:48 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_FAILURE_REASON: cannot create note because it is a duplicate
:END:
*** Front
in RL the task the agent is trying to solve may or may not have a natural ending. Tasks that have a natural ending, such as a game, are called ...
*** Back
episodic tasks

** 2022.06.05-12:01:04 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654419741406
:END:
*** Front
in RL tasks that don't have a *natural ending* are called ...
*** Back
continuing tasks
** 2022.06.05-13:19:25 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654424551200
:END:
*** Front
DQN is a ... algorithm
*** Back
Deep Reinforcement Learning
** 2022.06.05-13:20:35 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654424551300
:END:
*** Front
DQN came out in year ...
*** Back
2015
** 2022.06.05-13:21:30 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654424551374
:END:
*** Front
DQN uses ... to learn to play Atari games from raw pixels
*** Back
CNN (Convolutional Neural Networks)
** 2022.06.05-14:13:13 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654431150420
:END:
*** Front
*abundance* in Turkish?
*** Back
bolluk
** 2022.06.05-14:17:37 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654431150524
:END:
*** Front
*prudent* in Turkish?
*** Back
tedbirli
** 2022.06.05-15:08:03 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654431150609
:END:
*** Front
when you try to teach more than one tasks that are completely different to a DRL agent, the agent will ...
*** Back
1. not learn them well
** 2022.06.05-15:10:55 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654431150684
:END:
*** Front
DRL agents can learn only ... task well
*** Back
1. one
** 2022.06.05-15:19:28 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654433025184
:END:
*** Front
... allows the agent to explore new actions just for the sake of it, out of curiosity. Agents that use ... show improved learning performance in environments with sparse rewards
*** Back
Intrinsic motivation
** 2022.06.05-17:31:04 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654443587709
:END:
*** Front
The two core components in RL are the ... and the ...
*** Back
1. agent
2. environment
** 2022.06.05-17:31:37 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654443587785
:END:
*** Front
in RL the agent is the ... maker. and is the ... to a problem
*** Back
1. decision
2. solution
** 2022.06.05-17:32:30 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654443587859
:END:
*** Front
in RL the *environment* is the representation of a ...
*** Back
1. problem
** 2022.06.05-17:33:13 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654443587934
:END:
*** Front
in RL the agent attempts to ... the environment through ..., and the environment ... to the agent's ...
*** Back
1. influence
2. actions
3. reacts
4. actions
** 2022.06.05-17:43:42 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654443588010
:END:
*** Front
*parable* in Turkish?
*** Back
benzetme
** 2022.06.05-17:49:00 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654443588084
:END:
*** Front
*abbreviated* in Turkish?
*** Back
kısaltımış
** 2022.06.06-11:47:51 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654525071209
:END:
*** Front
Most *real-world decision-making* problems can be expressed as ...
*** Back
1. RL environments
** 2022.06.06-16:33:16 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654525071283
:END:
*** Front
*gait* in Turkish?
*** Back
yürüyüş
** 2022.06.06-16:57:39 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654525071359
:END:
*** Front
in RL the environment is represented by a set of variables related to the problem. The combination of all the possible values this set of variables can take is referred to as the ...
*** Back
state space
** 2022.06.06-16:59:04 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654525071433
:END:
*** Front
RL agents can observe something from the environment. The set of variables the agent perceives at any given time is called an ...
*** Back
observation
** 2022.06.06-17:00:22 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654525071508
:END:
*** Front
in RL community, two terms are used interchangeably. what are they?
*** Back
state and observation
** 2022.06.06-17:09:09 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654525071584
:END:
*** Front
in RL the interactions between the agent and the environment go on for several cycles. Each
cycle is called a ...
*** Back
1. time step.
** 2022.06.06-17:17:56 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654525476534
:END:
*** Front
in RL the combination of *set of observation*, *the action*, *reward* and *new observation* is called ...
*** Back
experience tuple

** 2022.06.07-16:24:17 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654611254214
:END:
*** Front
the *sum of rewards* collected in *single episode* is called a ...
*** Back
return
** 2022.06.07-16:25:59 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654611254510
:END:
*** Front
in RL which property the agent tries to *maximize*?
*** Back
return
** 2022.06.07-16:27:41 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654611254581
:END:
*** Front
in RL if the task is *continuing* then we add ... limit to make it *eposodic task*
*** Back
time step
** 2022.06.07-16:29:32 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654611254683
:END:
*** Front
in RL to make the agent to maximize the return, task needs to be ...
*** Back
episodic
** 2022.06.07-16:34:03 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654611254775
:END:
*** Front
in RL *the engine* of the environment is ...
*** Back
MDP (Markov Decision Processes)
** 2022.06.07-16:42:31 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654611254849
:END:
*** Front
*devise* in Turkish?
*** Back
tasarlamak
** 2022.06.07-17:13:52 :vocabulary:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654611254925
:END:
*** Front
*adequate* in Turkish?
*** Back
yeterli
** 2022.06.07-17:34:57 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654613948700
:END:
*** Front
in RL The *probability of the next state*, given the current state and action, is *independent of the history* of interactions. This *memoryless property* of MDPs is known as the ...
*** Back
Markov ­property
** 2022.06.07-17:38:28 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654613948776
:END:
*** Front
the *more variables* you add to the environment the ... will be the learning process for the agent
*** Back
longer
** 2022.06.07-17:39:28 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:ANKI_NOTE_ID: 1654613948850
:END:
*** Front
in RL the fewer variables you give to environment, the higher the chance the information fed to the agent is ...
*** Back
not sufficient
** 2022.06.07-19:57:36 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:END:
*** Front
in MDP *terminal states* are defined as states with all actions with *deterministic transitions* to ...
*** Back
themselves
** 2022.06.07-20:35:40 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:END:
*** Front
in RL when modeling a problem we use MDPs. what columns should we used (in order) to model our problem using a table format?
*** Back
| state | action | next state | transition prob | reward signal |
|-------+--------+------------+-----------------+---------------|
|       |        |            |                 |               |
** 2022.06.07-20:39:50 :ai:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_DECK: notitia
:END:
*** Front
in RL An *episodic task* is a task in which there’s a ... number of time steps, either because the ... stops or because the agent reaches a ... . There are also *continuing tasks*, which are tasks that go on ...; there are no ... states, so there’s an ... number of time steps. In this type of task, the agent must be stopped ... .
*** Back
1. finite
2. clock
3. terminal
4. forever
5. terminal
6. infinite
7. manually
